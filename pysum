#!/usr/bin/env python3
"""
Project Structure Generator

This script parses Python files in a project directory and generates a simplified
structure in Markdown format, showing classes and functions with their signatures.
"""

import os
import ast
import re
from typing import List, Dict, Any, Optional


class PyFileParser:
    """Parses Python files to extract class and function definitions."""

    def parse_file(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Parse a Python file and extract its structure."""
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()

            tree = ast.parse(content)
            imports = self._extract_imports(tree)
            classes = self._extract_classes(tree)
            functions = self._extract_functions(tree)

            if not (imports or classes or functions):
                return None

            return {
                'imports': imports,
                'classes': classes,
                'functions': functions
            }
        except Exception as e:
            print(f"Error parsing {file_path}: {e}")
            return None

    def _extract_imports(self, tree: ast.Module) -> List[str]:
        """Extract import statements from AST."""
        imports = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for name in node.names:
                    imports.append(f"import {name.name}")
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ''
                names = ', '.join(name.name for name in node.names)
                imports.append(f"from {module} import {names}")
        return imports

    def _extract_classes(self, tree: ast.Module) -> List[Dict[str, Any]]:
        """Extract class definitions from AST."""
        classes = []
        for node in ast.iter_child_nodes(tree):
            if isinstance(node, ast.ClassDef):
                class_info = {
                    'name': node.name,
                    'methods': []
                }

                # Extract base classes if any
                if node.bases:
                    bases = []
                    for base in node.bases:
                        if isinstance(base, ast.Name):
                            bases.append(base.id)
                        elif isinstance(base, ast.Attribute):
                            bases.append(f"{self._get_attribute_full_name(base)}")
                    if bases:
                        class_info['bases'] = bases

                # Extract methods
                for child in node.body:
                    if isinstance(child, ast.FunctionDef):
                        method_info = self._extract_function_info(child)
                        class_info['methods'].append(method_info)

                classes.append(class_info)
        return classes

    def _extract_functions(self, tree: ast.Module) -> List[Dict[str, str]]:
        """Extract function definitions from AST."""
        functions = []
        for node in ast.iter_child_nodes(tree):
            if isinstance(node, ast.FunctionDef):
                function_info = self._extract_function_info(node)
                functions.append(function_info)
        return functions

    def _extract_function_info(self, node: ast.FunctionDef) -> Dict[str, str]:
        """Extract information about a function or method."""
        args = []

        # Process arguments
        for arg in node.args.args:
            arg_str = arg.arg
            if arg.annotation:
                arg_str += f": {self._get_annotation_name(arg.annotation)}"
            args.append(arg_str)

        # Process default values
        defaults = node.args.defaults
        if defaults:
            default_offset = len(args) - len(defaults)
            for i, default in enumerate(defaults):
                args[default_offset + i] += f"={self._get_default_value(default)}"

        # Process *args and **kwargs
        if node.args.vararg:
            args.append(f"*{node.args.vararg.arg}")
        if node.args.kwarg:
            args.append(f"**{node.args.kwarg.arg}")

        # Build the function signature
        signature = f"def {node.name}({', '.join(args)})"

        # Add return type if present
        if node.returns:
            signature += f" -> {self._get_annotation_name(node.returns)}"

        return {
            'name': node.name,
            'signature': signature
        }

    def _get_annotation_name(self, annotation: ast.AST) -> str:
        """Convert an annotation AST node to its string representation."""
        if isinstance(annotation, ast.Name):
            return annotation.id
        elif isinstance(annotation, ast.Attribute):
            return self._get_attribute_full_name(annotation)
        elif isinstance(annotation, ast.Subscript):
            value = self._get_annotation_name(annotation.value)
            if isinstance(annotation.slice, ast.Index):  # Python 3.8 and below
                slice_value = self._get_annotation_name(annotation.slice.value)
            else:  # Python 3.9+
                slice_value = self._get_annotation_name(annotation.slice)
            return f"{value}[{slice_value}]"
        elif isinstance(annotation, ast.Tuple):
            elts = [self._get_annotation_name(elt) for elt in annotation.elts]
            return f"({', '.join(elts)})"
        elif isinstance(annotation, ast.Constant):
            return str(annotation.value)
        else:
            return "Any"  # Default fallback

    def _get_attribute_full_name(self, node: ast.Attribute) -> str:
        """Get the full dotted name of an attribute."""
        if isinstance(node.value, ast.Name):
            return f"{node.value.id}.{node.attr}"
        elif isinstance(node.value, ast.Attribute):
            return f"{self._get_attribute_full_name(node.value)}.{node.attr}"
        return node.attr

    def _get_default_value(self, node: ast.AST) -> str:
        """Convert a default value AST node to its string representation."""
        if isinstance(node, ast.Constant):
            if isinstance(node.value, str):
                return f"'{node.value}'"
            return str(node.value)
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return "[]"
        elif isinstance(node, ast.Dict):
            return "{}"
        elif isinstance(node, ast.Tuple):
            return "()"
        elif isinstance(node, ast.Call):
            if isinstance(node.func, ast.Name):
                return f"{node.func.id}()"
            elif isinstance(node.func, ast.Attribute):
                return f"{self._get_attribute_full_name(node.func)}()"
        return "..."


class ProjectStructureGenerator:
    """Generates a Markdown representation of project structure."""

    def __init__(self, project_dir: str, output_file: str = "project_structure.md"):
        self.project_dir = os.path.abspath(project_dir)
        self.output_file = output_file
        self.parser = PyFileParser()

    def generate(self):
        """Generate the project structure document."""
        python_files = self._find_python_files()
        file_structures = {}

        for file_path in python_files:
            rel_path = os.path.relpath(file_path, self.project_dir)
            structure = self.parser.parse_file(file_path)
            if structure:
                file_structures[rel_path] = structure

        self._write_markdown(file_structures)
        print(f"Project structure generated in {self.output_file}")

    def _find_python_files(self) -> List[str]:
        """Find all Python files in the project directory."""
        python_files = []
        for root, _, files in os.walk(self.project_dir):
            for file in files:
                if file.endswith('.py'):
                    python_files.append(os.path.join(root, file))
        return sorted(python_files)

    def _write_markdown(self, file_structures: Dict[str, Dict[str, Any]]):
        """Write the project structure to a Markdown file."""
        with open(self.output_file, 'w', encoding='utf-8') as f:
            f.write("# Project Structure\n\n")

            for file_path, structure in file_structures.items():
                f.write(f"## {file_path}\n```python\n")

                # Write imports
                if structure['imports']:
                    for imp in structure['imports']:
                        f.write(f"{imp}\n")
                    f.write("\n")

                # Write classes
                for cls in structure['classes']:
                    # Write class definition with inheritance if applicable
                    if 'bases' in cls:
                        f.write(f"class {cls['name']}({', '.join(cls['bases'])})\n")
                    else:
                        f.write(f"class {cls['name']}\n")

                    # Write methods
                    if cls['methods']:
                        for method in cls['methods']:
                            f.write(f"    {method['signature']}\n")
                    else:
                        f.write("    pass\n")
                    f.write("\n")

                    # Write standalone functions
                    for func in structure['functions']:
                        f.write(f"{func['signature']}\n")
                        if func != structure['functions'][-1]:
                            f.write("\n")

                    f.write("```\n\n")

def main():
    """Main entry point for the script."""
    import argparse

    parser = argparse.ArgumentParser(description='Generate a simplified project structure document.')
    parser.add_argument('--dir', '-d', default='.',
                        help='Project directory to analyze (default: current directory)')
    parser.add_argument('--output', '-o', default='project_structure.md',
                        help='Output file path (default: project_structure.md)')

    args = parser.parse_args()

    generator = ProjectStructureGenerator(args.dir, args.output)
    generator.generate()

if __name__ == '__main__':
    main()

